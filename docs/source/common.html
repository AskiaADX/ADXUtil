<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">    // Filesystem
var fs = require(&#39;fs&#39;),
    // Path helper
    pathHelper = require(&#39;path&#39;),
    // Util
    util   = require(&#39;util&#39;),
    // cli-color
    clc      = require(&#39;cli-color&#39;),
    // Zip lib
    Zip    = require(&#39;JSZip&#39;);

exports = module.exports;

// Application name
exports.APP_NAME = &#39;ADXUtil&#39;;

// Preferences
exports.PREFERENCES_FILE_NAME = &#39;preferences.json&#39;;

// Common
// File name of the config.xml
exports.CONFIG_FILE_NAME = &#39;config.xml&#39;;
// File name of the readme.md
exports.README_FILE_NAME = &#39;readme.md&#39;;
// Path of the unit tests directory
exports.UNIT_TEST_DIR_PATH = &quot;tests/units&quot;;
// Path of the fixtures directory
exports.FIXTIRES_DIR_PATH = &quot;tests/fixtures&quot;;

// Validator
//  Path to the XML Lint program
exports.XML_LINT_PATH   = &#39;/lib/libxml/xmllint.exe&#39;;
// Path to the XSD schema file to validate the ADX config.xml
exports.SCHEMA_PATH     = &#39;/schema/&#39;;
// Name of the schema to validate the ADC config file
exports.SCHEMA_ADC   = &#39;ADCSchema.xsd&#39;;
// Name of the schema to validate the ADC config file
exports.SCHEMA_ADP = &#39;ADPSchema.xsd&#39;;
// Name of the schema to validate the unit test file
exports.SCHEMA_TEST_UNIT   = &#39;UnitTests.xsd&#39;;
// Path to the directory of the ADXShell program
exports.ADX_UNIT_DIR_PATH   = &#39;/lib/adxshell_&#39; + ((process.arch === &#39;x64&#39;) ? &#39;x64&#39; : &#39;x86&#39;) + &#39;/&#39;;
// ADCUnit.exe
exports.ADX_UNIT_PROCESS_NAME = &#39;ADXShell.exe&#39;;
// Name of the `resources` directory
exports.RESOURCES_DIR_NAME = &quot;resources&quot;;
// Name of the directory `dynamic`
exports.DYNAMIC_DIR_NAME = &quot;dynamic&quot;;
// Name of the directory `static`
exports.STATIC_DIR_NAME = &quot;static&quot;;
// Name of the directory `share`
exports.SHARE_DIR_NAME = &quot;share&quot;;

// File name which contains the list of files to ignore
exports.ADX_IGNORE_FILE_NAME = &quot;ADXIgnore&quot;;
// Ignore file list
exports.adxIgnoreFiles = &quot;&quot;;
// Rules to ignore files
exports.adxIgnoreFilesRules = undefined;

// Generator
// Path of the templates directory
exports.TEMPLATES_PATH = &#39;/templates/&#39;;
exports.DEFAULT_TEMPLATE_NAME = &#39;blank&#39;;


// Builder
// Path to the bin directory of an ADX
exports.ADX_BIN_PATH  = &#39;/bin/&#39;;


// Error messages
exports.messages = {
    error : {
        // Common
        noSuchFileOrDirectory   : &quot;No such file or directory `%s`&quot;,

        // Validator
        missingArgPath          : &quot;Missing `path` argument&quot;,
        noConfigFile            : &quot;Cannot find the `Config.xml` file in the directory&quot;,
        fileExtensionForbidden  : &quot;File extension `%s` is forbidden&quot;,
        duplicateConstraints    : &quot;Duplicate constraints on `%s`&quot;,
        invalidConstraintAttribute : &quot;The constraint on `%s` doesn&#39;t accept the `%s` attribute&quot;,
        noRuleOnConstraint      : &quot;The constraint on `%s` require at least one rule&quot;,
        requireConstraintOn     : &quot;A constraint on `%s` is required&quot;,
        tooManyEmptyCondition   : &quot;Too many outputs with empty condition: %s&quot;,
        noResourcesDirectory    : &quot;Cannot find the `resources` directory&quot;,
        dynamicFileRequire      : &quot;At least one dynamic file is required for the `%s` output, or set the attribute `defaultGeneration=true` in the output node&quot;,
        cannotFindDirectory     : &quot;Cannot find the `%s` directory&quot;,
        cannotFindFileInDirectory : &quot;Output: `%s`. Cannot find the file `%s` in the `%s` directory&quot;,
        typeCouldNotBeDynamic       : &quot;Output: `%s`. Type `%s` could not be dynamic (`%s`)&quot;,
        attributeNotOverridable : &quot;Output: `%s`. Attribute `%s` of the `%s` content could not be override&quot;,
        yieldRequireForBinary   : &quot;Output: `%s`. `yield` node required for the binary content `%s` or set his position to `none`&quot;,
        duplicateAttributeNode  : &quot;Output: `%s`. Duplicate `%s` attribute node in content `%s`&quot;,
        missingInfoNode         : &quot;The config.xml must contains the `info` node as a child of the xml root element&quot;,
        missingOrEmptyNameNode   : &quot;The node `name` in `info` doesn&#39;t exist or is empty&quot;,
        missingOrEmptyMasterPageAttr   : &quot;Output: `%s`. The `masterPage` attribute doesn&#39;t exist or is empty&quot;,
        masterPageRequireAskiaHeadTag : &quot;The master page `%s` doesn&#39;t contains the `askia-head`  tag&quot;,
        masterPageRequireOnlyOneAskiaHeadTag : &quot;The master page `%s` contains more than one `askia-head` tag&quot;,
        masterPageRequireAskiaFootTag : &quot;The master page `%s` doesn&#39;t contains the `askia-foot`  tag&quot;,
        masterPageRequireOnlyOneAskiaFootTag : &quot;The master page `%s` contains more than one `askia-foot` tag&quot;,
        masterPageRequireAskiaFormTag : &quot;The master page `%s` doesn&#39;t contains the `askia-form` tag&quot;,
        masterPageRequireOnlyOneAskiaFormTag : &quot;The master page `%s` contains more than one `askia-form` tag`&quot;,
        masterPageRequireAskiaFormCloseTag : &quot;In the master page `%s` the `askia-form` tag is not close&quot;,
        masterPageRequireOnlyOneAskiaFormCloseTag : &quot;In the master page `%s` the `askia-form` tag seems closed twice`&quot;,
        masterPageRequireAskiaQuestionsTag : &quot;The master page `%s` doesn&#39;t contains the `askia-questions` tag&quot;,
        masterPageRequireOnlyOneAskiaQuestionsTag : &quot;The master page `%s` contains more than one `askia-questions` tag`&quot;,
        masterPageRequireAskiaQuestionsTagInsideAskiaFormTag : &quot;In the master page `%s` the `askia-questions` tag seems not inside the `askia-form` tag&quot;,

        // Generator
        missingTypeArgument     : &quot;The `type` parameter is required&quot;,
        incorrectADXType        : &quot;Incorrect ADX type. Expected `adc` or `adp`.&quot;,
        missingNameArgument     : &quot;The `name` parameter is required&quot;,
        missingOutputArgument   : &quot;The --output path is required&quot;,
        directoryAlreadyExist   : &quot;The directory `%s` already exists.&quot;,
        incorrectADXName        : &quot;Incorrect ADX name. The name of the ADX should only contains letters, digits, spaces, `_,-,.` characters&quot;,
        cannotFoundTemplate     : &quot;Cannot found the `%s` template&quot;,

        // Builder
        validationFailed        : &quot;Validation failed&quot;,
        buildFailed             : &quot;Build failed with errors.&quot;,

        // Show
        noOutputDefinedForShow  : &quot;Please specify the name of the output you want to show, using the option -o or --output.&quot;,
        noFixtureDefinedForShow : &quot;Please specify the name of the fixture you want to use, using the option -f or --fixture.&quot;,

        // Configurator
        invalidPathArg          : &quot;Invalid `path` argument&quot;,
        invalidConfigFile       : &quot;Invalid `config.xml` file&quot;
    },
    warning : {
        // Validator
        untrustExtension            : &quot;Un-trust extension of the file `%s`&quot;,
        duplicateOutputCondition    : &quot;Duplicate conditions in outputs `%s` and `%s`&quot;,
        attributeNodeWillBeIgnored  : &quot;Output: `%s`. `attribute` nodes will be ignored for the `%s` content (`%s`)&quot;,
        attributeNodeAndDynamicContent : &quot;Output: `%s`. `attribute` nodes will be ignored for dynamic content (`%s`)&quot;,
        attributeNodeAndYieldNode   : &quot;Output: `%s`. `attribute` nodes will be ignored when using `yield` (`%s`)&quot;,
        javascriptUseWithoutBrowserCheck : &quot;Output: `%s`. It&#39;s recommended to test the `Browser.Support(\&quot;Javascript\&quot;) in the condition node, before to use `javascript` content.&quot;,
        flashUseWithoutBrowserCheck : &quot;Output: `%s`. It&#39;s recommended to test the `Browser.Support(\&quot;Flash\&quot;) in the condition node, before to use `flash` content.&quot;,
        noHTMLFallBack              : &quot;It&#39;s recommended to have at least one fallback with HTML only&quot;,
        noProperties                : &quot;It&#39;s recommended to define at least one properties&quot;,
        deprecatedInfoStyleTag      : &quot;[Deprecated]: The `info &gt; style` tag is mark as deprecated in 2.1.0, it will not longer be supported in the next ADX version.\r\nPlease avoid it&#39;s usage&quot;,
        deprecatedInfoCategoriesTag : &quot;[Deprecated]: The `info &gt; categories` tag is mark as deprecated in 2.1.0, it will not longer be supported in the next ADX version.\r\nPlease avoid it&#39;s usage&quot;,
        deprecatedDefaultGenerationAttr : &quot;[Deprecated]: The `output &gt; defaultGeneration` attribute is mark as deprecated in 2.1.0, it will not longer be supported in the next ADX version.\r\nPlease avoid it&#39;s usage&quot;
    },
    success : {
        // Validator
        pathValidate               : &quot;ADX path validation done&quot;,
        directoryStructureValidate : &quot;ADX directory structure validation done&quot;,
        fileExtensionValidate      : &quot;File extension validation done&quot;,
        xsdValidate                : &quot;XSD validation done&quot;,
        xmlInitialize              : &quot;Config.xml parsing done&quot;,
        xmlInfoValidate            : &quot;Config#info validation done&quot;,
        xmlInfoConstraintsValidate : &quot;Config#info#constraints validation done&quot;,
        xmlOutputsValidate         : &quot;Config#outputs validation done&quot;,
        xmlPropertiesValidate      : &quot;Config#properties validation done&quot;,
        masterPageAskiaTagsValidate     : &quot;Master page with Askia tags validation done&quot;,
        adxUnitSucceed             : &quot;ADX Unit tests succeeded&quot;,

        // Generator
        adxStructureGenerated : &quot;Project structure\r\n\r\n%s\r\n\r\nADX `%s` was successfully generated in `%s`\r\n&quot;,

        // Builder
        buildSucceed           : &quot;ADX file was successfully generated.\r\nOutput: file:///%s&quot;,
        buildSucceedWithWarning: &quot;ADX file was successfully generated with %d warnings.\r\nOutput: file:///%s&quot;
    },
    message : {
        // Validator
        runningADXUnit   : &#39;Running ADX Unit tests&#39;,
        runningAutoUnit  : &#39;Running the auto-generated ADX Unit tests&#39;,
        validationFinishedIn       : &quot;\r\nValidations finished in %d milliseconds&quot;,
        validationReport : &quot;\r\n%d/%d validations runs, %d success, %d warnings, %d failures, %d skipped&quot;,

        // Preferences
        noPreferences  : &#39;No preferences defined&#39;
    }
};

/*
 * Write an error output in the console
 * @param {String} text Text to write in the console
 */
exports.writeError = function writeError(text) {
    console.error(clc.red.bold(&quot;[ERROR]: &quot; + text));
};

/*
 * Write a warning output in the console
 * @param {String} text Text to write in the console
 */
exports.writeWarning = function writeWarning(text) {
    console.log(clc.yellowBright(&quot;[WARNING]: &quot; + util.format.apply(null, arguments)));
};

/*
 * Write a success output in the console
 * @param {String} text Text to write in the console
 */
exports.writeSuccess = function writeSuccess(text) {
    console.log(clc.greenBright(&quot;[SUCCESS]: &quot; + util.format.apply(null, arguments)));
};

/*
 * Write an arbitrary message in the console without specific prefix
 * @param {String} text Text to write in the console
 */
exports.writeMessage = function writeMessage(text) {
    console.log(util.format.apply(null, arguments));
};

/*
 * Get a new zip object
 */
exports.getNewZip = function getNewZip() {
    return new Zip();
};

/*
 * Format the date for xml.
 * If no date in arg, use the current date
 * @param {Date} [date] Date to format
 */
exports.formatXmlDate = function formatXmlDate(date) {
    (date = date || new Date());
    return padStr(date.getFullYear()) + &#39;-&#39; + padStr(1 + date.getMonth()) + &#39;-&#39; + padStr(date.getDate());
};

/*
 * Pad the number with one 0 when &lt; 10
 * @param {Number} i Number to pad
 * @return {String}
 */
function padStr(i) {
    return (i &lt; 10) ? &quot;0&quot; + i : &quot;&quot; + i;
}

/*
 * Test if a directory exists
 * @param {String} path Path of the directory
 * @param {Function} callback Callback function with err, exists arguments
 */
exports.dirExists = function dirExists (path, callback) {
    fs.stat(path, function(err) {
        // errno 2 -- ENOENT, No such file or directory
        if (err &amp;&amp; err.errno === 2) {
            callback(null, false);
        } else {
            callback(err, err ? false : true);
        }
    });
};

/*
 * Indicates if the file should be ignore
 *
 * @param {String} filename Name of the file
 * @return {Boolean} True when should be ignored
 */
exports.isIgnoreFile = function isIgnoreFile(filename) {
    if (!exports.adxIgnoreFiles) {
        exports.adxIgnoreFiles = fs.readFileSync(pathHelper.resolve(__dirname, &quot;../&quot; + exports.ADX_IGNORE_FILE_NAME), &#39;utf8&#39;);
    }

    if (!exports.adxIgnoreFilesRules) {
        var lines = exports.adxIgnoreFiles.split(&#39;\n&#39;),
            rgExp = [];
        lines.forEach(function (line) {
            line = line.replace(/(#.*)/g, &#39;&#39;);
            line = line.replace(/\s/g, &#39;&#39;);
            line = line.replace(/\r/g, &#39;&#39;);
            if (!line) return;
            line = line.replace(/\./g, &quot;\\.&quot;);
            line = line.replace(/-/g, &quot;\\-&quot;);
            line = line.replace(/\*/g, &quot;.*&quot;);
            rgExp.push(line);
        });

        exports.adxIgnoreFilesRules = new RegExp(&quot;(&quot; + rgExp.join(&quot;|&quot;) + &quot;)$&quot;, &quot;gi&quot;);
    }

    return exports.adxIgnoreFilesRules.test(filename);
};

/*
 * Return the entire directory structure
 *
 *  [
 *      {
 *          name : &#39;folder&#39;,
 *          sub  : [
 *              {
 *                  name : &#39;sub folder&#39;,
 *                  sub  : []
 *              },
 *              {
 *                  name : &#39;sub folder 2&#39;
 *                  sub  : [
 *                      &#39;file&#39;,
 *                      &#39;file2&#39;
 *                  ]
 *              }
 *          ]
 *      }
 * ]
 *
 * @param {String} path Path of the root directory
 * @param {Function} callback Callback function
 */
exports.getDirStructure = function getDirStructure(path, callback) {
    fs.stat(path, function verifyRoot(err, stat) {
        if (err) {
            return callback(err);
        }
        if (!stat.isDirectory()) {
            return callback(new Error(&quot;path: &quot; + path + &quot; is not a directory&quot;));
        }

        function record(root, file, struct, cb) {
            var fullPath = root + &#39;/&#39; + file,
                stat;
            try {
                stat = fs.statSync(fullPath);
            } catch(err) {
                if (cb) cb();
                return;
            }

            if (!stat.isDirectory()) {
                struct.push(file);
            } else {
                struct.push({
                    name : file,
                    sub  : []
                });

                // Recurse
                var files      = fs.readdirSync(fullPath),
                    lastStruct = struct[struct.length -1].sub;
                if (files &amp;&amp; Array.isArray(files)) {
                    files.forEach(function (f) {
                        record(fullPath, f, lastStruct);
                    });
                }
            }
            if (cb) cb();
        }

        // Read through all the files in this directory
        var structure = [],
            files     = fs.readdirSync(path),
            treat     = 0,
            rootLength = files &amp;&amp; files.length;

        if (!files || !Array.isArray(files) || !rootLength) {
            callback(null, structure);
        }

        function incrementTreat() {
            treat++;
            if (treat === rootLength) {
                callback(null, structure);
            }
        }
        files.forEach(function (file) {
            record(path, file, structure, incrementTreat);
        });
    });
};

/*
 * Returns the list of templates directory
 *
 * It searches in the user data folder, the program data folder and the installation program folder
 *
 * @param {&quot;adc&quot;|&quot;adp&quot;} type Type of the template list to obtain (`adc` or `adp`)
 * @param {Function} callback Callback
 * @param {Error} callback.err Error
 * @param {Object[]} callback.dirs List of template
 * @param {String} callback.dirs[].name Name of the template
 * @param {String} callback.dirs[].path Path of the template directory
 */
exports.getTemplateList = function getTemplateList(type, callback) {
    if (!type &amp;&amp; typeof callback !== &#39;function&#39;) {
        throw new Error(exports.messages.error.missingTypeArgument);
    }

    if (typeof callback === &#39;function&#39; &amp;&amp; type !== &#39;adc&#39; &amp;&amp; type !== &#39;adp&#39;) {
        callback(new Error(exports.messages.error.incorrectADXType));
        return;
    }

    // 1. Get the templates from the application path
    // 2. Get the templates from the PROGRAM_DATA path
    // 3. Get the templates from the USER_DATA path
    var result = [], map = {};
    function addFiles(parent, files) {
        for (var i = 0, l = files.length; i &lt; l; i++) {
            var fullPath = pathHelper.join(parent, files[i]),
                stat = fs.statSync(fullPath),
                name, lowerName, dir;
            if (stat.isDirectory()) {
                name = pathHelper.basename(files[i]);
                lowerName = name.toLowerCase();
                dir = {
                    name : name,
                    path : fullPath
                };
                if (lowerName in map) {
                    result[map[lowerName]] = dir;
                } else {
                    map[lowerName] = result.length;
                    result.push(dir);
                }
            }
        }
    }

    // 1.
    var sysTemplatePath = pathHelper.resolve(__dirname, &#39;../../&#39;);
    sysTemplatePath = pathHelper.join(sysTemplatePath, exports.TEMPLATES_PATH, type);
    fs.readdir(sysTemplatePath, function (err, files) {
        if (!err) {
            addFiles(sysTemplatePath, files);
        }

        // 2.
        var programDataPath = process.env.ALLUSERSPROFILE || process.env.ProgramData || &#39;&#39;;
        programDataPath = pathHelper.join(programDataPath, exports.APP_NAME , exports.TEMPLATES_PATH, type);
        fs.readdir(programDataPath, function (err, files) {
            if (!err) {
                addFiles(programDataPath, files);
            }

            // 3.
            var userDataPath = process.env.APPDATA || &#39;&#39;;
            userDataPath = pathHelper.join(userDataPath, exports.APP_NAME , exports.TEMPLATES_PATH, type);
            fs.readdir(userDataPath, function (err, files) {
                if (!err) {
                    addFiles(userDataPath, files);
                }

                callback(null, result);
            });
        });
    });
};

/*
 * Returns the path of the template according to his name
 *
 * It searches in the user data folder, the program data folder and the installation program folder
 *
 * @param {&quot;adc&quot;|&quot;adp&quot;} type Type of the template list to obtain (`adc` or `adp`)
 * @param {String} name Name of the template to search
 * @param {Function} callback Callback
 * @param {Error} callback.err Error
 * @param {String} callback.path Path of the template
 */
exports.getTemplatePath = function getTemplatePath(type, name, callback) {
    if (!type &amp;&amp; typeof callback !== &#39;function&#39;) {
        throw new Error(exports.messages.error.missingTypeArgument);
    }

    if (typeof name === &#39;function&#39;) {
        name(new Error(exports.messages.error.missingNameArgument));
        return;
    }

    if (typeof callback === &#39;function&#39; &amp;&amp; type !== &#39;adc&#39; &amp;&amp; type !== &#39;adp&#39;) {
        callback(new Error(exports.messages.error.incorrectADXType));
        return;
    }

    // 1. Search in the USER_DATA path
    // 2. Search in the PROGRAM_DATA path
    // 3. Search in the installation path

    // 1.
    var userDataPath = process.env.APPDATA || &#39;&#39;;
    userDataPath = pathHelper.join(userDataPath, exports.APP_NAME , exports.TEMPLATES_PATH, type, name);
    exports.dirExists(userDataPath, function (err, exist) {
        if (exist) {
            callback(null, userDataPath);
            return;
        }

        // 2.
        var programDataPath = process.env.ALLUSERSPROFILE || process.env.ProgramData || &#39;&#39;;
        programDataPath = pathHelper.join(programDataPath, exports.APP_NAME , exports.TEMPLATES_PATH, type, name);
        exports.dirExists(programDataPath, function (err, exist) {
            if (exist) {
                callback(null, programDataPath);
                return;
            }

            // 3.
            var sysTemplatePath = pathHelper.resolve(__dirname, &#39;../../&#39;);
            sysTemplatePath = pathHelper.join(sysTemplatePath, exports.TEMPLATES_PATH, type, name);
            exports.dirExists(sysTemplatePath, function (err, exist) {
                if (exist) {
                    callback(null, sysTemplatePath);
                    return;
                }

                callback(new Error(util.format(exports.messages.error.cannotFoundTemplate, name)), null);
            });
        });
    });
};

<span id='Sequence'>/**
</span> * Create a new sequence of function to call
 *
 * @class Sequence
 * @private
 */
function Sequence(sequence, callback, scope) {
    this.current  = -1;
    this.sequence = sequence;
    this.callback = callback;
    this.scope    = scope;
}

<span id='Sequence-method-constructor'>/**
</span> * Creates a new instance of sequence
 *
 * @param {Array} sequence Array of function to call one by one
 * @param {Function} callback Callback function to execute at the end of the sequence
 * @param {Object} [scope] Scope of function to execute (this)
 * @constructor
 */
Sequence.prototype.constructor = Sequence;

<span id='Sequence-method-nextIndex'>/**
</span> * Return the index of the next function to execute
 * @return {Number}
 */
Sequence.prototype.nextIndex = function nextIndex() {
    if (!this.sequence || !Array.isArray(this.sequence) || !this.sequence.length) {
        return -1;
    }
    var i  = (this.current + 1),
        l  = this.sequence.length;
    for (;i &lt; l; i++) {
        if (typeof this.sequence[i] === &#39;function&#39;) {
            return i;
        }
    }
    return -1;
};

<span id='Sequence-method-hasNext'>/**
</span> * Indicates if there is another function to call in the sequence stack
 * @returns {boolean}
 */
Sequence.prototype.hasNext = function hasNext() {
    return (this.nextIndex() !== -1);
};

<span id='Sequence-method-resume'>/**
</span> * Execute the next function
 * @param {Error} err Error
 */
Sequence.prototype.resume = function resume(err) {
    var index = this.nextIndex();
    if (index === -1 || err) {
        if (typeof this.callback === &#39;function&#39;) {
            this.callback.call(this.scope, err);
        }
        return;
    }
    this.current = index;
    this.sequence[this.current].call(this.scope);
};

exports.Sequence = Sequence;




</pre>
</body>
</html>

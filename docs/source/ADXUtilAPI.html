<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var fs      = require(&#39;fs&#39;);
var path    = require(&#39;path&#39;);
var wrench  = require(&#39;wrench&#39;);
var common  = require(&#39;./common/common.js&#39;);
var errMsg  = common.messages.error;
var Validator    = require(&#39;./validator/ADXValidator.js&#39;).Validator;
var Builder      = require(&#39;./builder/ADXBuilder.js&#39;).Builder;
var Publisher = require(&#39;./publisher/ADXPublisher.js&#39;).Publisher;
var Show         = require(&#39;./show/ADXShow.js&#39;).Show;
var Generator    = require(&#39;./generator/ADXGenerator.js&#39;).Generator;
var Configurator = require(&#39;./configurator/ADXConfigurator.js&#39;).Configurator;
var InteractiveADXShell = require(&#39;./common/InteractiveADXShell.js&#39;).InteractiveADXShell;
var InterviewsFactory   = require(&#39;./interviews/ADXInterviews.js&#39;).InterviewsFactory;
var preferences = require(&#39;./preferences/ADXPreferences.js&#39;).preferences;


<span id='ADX'>/**
</span> * Object used to generate, validate, show and build an ADX
 *
 *
 * Example of usage of existing ADX
 *
 *      var ADX = require(&#39;adxutil&#39;).ADX;
 *      var myAdx = new ADX(&#39;path/to/adx/dir&#39;);
 *
 *      // Validate an ADX
 *      myAdx.validate({test : false, autoTest : false}, function (err, report) {
 *          // Callback when the ADX structure has been validated
 *      });
 *
 *      // Show the output of an ADX
 *      myAdx.show({ output : &#39;fallback&#39;, fixture : &#39;single.xml&#39;  },  function (err, output) {
 *          // Callback with the output of the ADX
 *      });
 *
 *      // Build the ADX (package it)
 *      myAdx.build({test : false, autoTest : false}, function (err, path, report) {
 *          // Callback when the ADX has been built
 *      });
 *
 * Generate and use the new ADX instance
 *
 *      ADX.generate(&#39;adc&#39;, &#39;myNewADC&#39;, {output : &#39;/path/of/parent/dir&#39;, template : &#39;blank&#39;}, function (err, adc) {
 *          console.log(adc.path);
 *          adc.load(function (err) {
 *              if (err) {
 *                  console.log(err);
 *                  return;
 *              }
 *              console.log(adc.configurator.info.get());
 *          });
 *      });
 *
 *
 * @class ADX
 */
function ADX(adxDirPath) {
    if (!adxDirPath) {
        throw new Error(errMsg.invalidPathArg);
    }

    // Let it throw an exception
    fs.statSync(adxDirPath);

<span id='ADX-property-path'>    /**
</span>     * Path to the ADX directory
     * @type {string}
     */
    this.path = path.normalize(adxDirPath);

<span id='ADX-property-configurator'>    /**
</span>     * Configurator of the ADX
     * Expose the object to manipulate the config.xml
     *
     * @type {ADX.Configurator}
     */
    this.configurator = null;

<span id='ADX-property-_adxShell'>    /**
</span>     * Interactive ADX Shell
     *
     * @type {InteractiveADXShell}
     * @private
     */
    this._adxShell = new InteractiveADXShell(this.path);

<span id='ADX-property-interviews'>    /**
</span>     * Factory of interviews
     *
     * @type {ADX.InterviewsFactory}
     */
    this.interviews = new InterviewsFactory(this.path);
}

<span id='ADX-method-constructor'>/**
</span> * Create a new instance of ADX object
 *
 *
 *      var ADX = require(&#39;adxutil&#39;).ADX;
 *      var myAdx = new ADX(&#39;path/to/adx/dir&#39;);
 *
 * @constructor
 * @param {String} adxDirPath Path of the ADX directory
 */
ADX.prototype.constructor = ADX;

<span id='ADX-method-load'>/**
</span> * Load the config of the current ADX instance
 *
 *
 *      var ADX = require(&#39;adxutil&#39;).ADX;
 *      var myAdx = new ADX(&#39;path/to/adx/dir&#39;);
 *
 *      // Load an ADX
 *      myAdx.load(function (err) {
 *          // Callback when the ADX has been loaded
 *      });
 *
 * @param {Function} [callback] Callback function
 * @param {Error} [callback.err] Error
 */
ADX.prototype.load = function load(callback) {
    var configurator = new Configurator(this.path),
        self        = this;
    callback = callback || function (){};
    configurator.load(function (err) {
        if (err) {
            callback(err);
            return;
        }
        self.configurator = configurator;
        callback(null);
    });
};

<span id='ADX-method-validate'>/**
</span> * Validate the current ADX instance
 *
 *
 *      var ADX = require(&#39;adxutil&#39;).ADX;
 *      var myAdx = new ADX(&#39;path/to/adx/dir&#39;);
 *
 *      // Validate an ADX
 *      myAdx.validate({test : false, autoTest : false}, function (err, report) {
 *          // Callback when the ADX structure has been validated
 *      });
 *
 * @param {Object} [options] Options of validation
 * @param {String|&#39;default&#39;|&#39;html&#39;} [options.printMode=&#39;default&#39;] Print mode (default console or html)
 * @param {Boolean} [options.test=true] Run unit tests
 * @param {Boolean} [options.autoTest=true] Run auto unit tests
 * @param {Boolean} [options.xml=true] Validate the config.xml file
 * @param {Object} [options.logger] Logger
 * @param {Function} [options.writeMessage] Function where regular messages will be print
 * @param {Function} [options.writeSuccess] Function where success messages will be print
 * @param {Function} [options.writeWarning] Function where warning messages will be print
 * @param {Function} [options.writeError] Function where error messages will be print
 * @param {Function} [callback] Callback function
 * @param {Error} [callback.err] Error
 * @param {Object} [callback.report] Validation report
 */
ADX.prototype.validate = function validate(options, callback) {
    var validator = new Validator(this.path);
    options = options || {};
    options.adxShell = this._adxShell;
    validator.validate(options, callback);
};

<span id='ADX-method-build'>/**
</span> * Build the ADX
 *
 *      var ADX = require(&#39;adxutil&#39;).ADX;
 *      var myAdx = new ADX(&#39;path/to/adx/dir&#39;);
 *
 *      // Build the ADX (package it)
 *      myAdx.build({test : false, autoTest : false}, function (err, path, report) {
 *          // Callback when the ADX has been built
 *      });
 *
 * @param {Object} [options] Options of validation
 * @param {String|&#39;default&#39;|&#39;html&#39;} [options.printMode=&#39;default&#39;] Print mode (default console or html)
 * @param {Boolean} [options.test=true] Run unit tests
 * @param {Boolean} [options.autoTest=true] Run auto unit tests
 * @param {Object} [options.logger] Logger
 * @param {Function} [options.writeMessage] Function where regular messages will be print
 * @param {Function} [options.writeSuccess] Function where success messages will be print
 * @param {Function} [options.writeWarning] Function where warning messages will be print
 * @param {Function} [options.writeError] Function where error messages will be print
 * @param {Function} [callback] Callback function
 * @param {Error} [callback.err] Error
 * @param {String} [callback.outputPath] Path of the output
 * @param {Object} [callback.report] Validation report
 */
ADX.prototype.build = function build(options, callback){
    var builder = new Builder(this.path);
    options = options || {};
    options.adxShell = this._adxShell;
    builder.build(options, callback);
};


<span id='ADX-method-publish'>/**
</span> * Publish to publisher
 *
 *		var ADX = require(&#39;adxutil&#39;).ADX;
 *      var myAdx = new ADX(&#39;path/to/adx/dir&#39;);
 *
 *      // Publish the ADC
 *      myAdx.publish(platform,{username : &quot;&quot;, password : &quot;&quot;,  --url : &quot;https://...&quot;, --demoUrl : &quot;https://...&quot;} ,function (err) {
 *          // Callback when the ADC has been published
 *      });
 *
 * @param {String} platform Name of the platform to push
 * @param {Object} options Options of the platform
 * @param {Boolean} [options.silent=false] By pass the output
 * @param {Function} callback
 * @param {Error} [callback.err=null]
 */
ADX.prototype.publish = function publish(platform, options, callback){
  var publisher = new Publisher(this.path);
    options = options || {};
    options.adxShell = this._adxShell;
    publisher.publish(platform, options, callback);
};

<span id='ADX-method-show'>/**
</span> * Show the ADX output
 *
 *      var ADX = require(&#39;adxutil&#39;).ADX;
 *      var myAdx = new ADX(&#39;path/to/adx/dir&#39;);
 *
 *      // Show the output of an ADX
 *      myAdx.show({ output : &#39;fallback&#39;, fixture : &#39;single.xml&#39;  },  function (err, output) {
 *          // Callback with the output of the ADX
 *      });
 *
 * @param {Object} options Options
 * @param {String} options.output Name of the ADX Output to use
 * @param {String} options.fixture FileName of the ADX fixture to use
 * @param {String} [options.masterPage] Path of the master page to use (ADC Only)
 * @param {Boolean} [options.silent=false] Silent mode: Don&#39;t message in the console but only through the callback
 * @param {Function} callback Callback function
 * @param {Error} callback.err Error
 * @param {String} callback.output Output string
 */
ADX.prototype.show = function show(options, callback) {
    var show = new Show(this.path);
    options = options || {};
    options.adxShell = this._adxShell;
    show.show(options, callback);
};

<span id='ADX-method-getFixtureList'>/**
</span> * Returns the list of fixtures
 *
 *      var ADX = require(&#39;adxutil&#39;).ADX;
 *      var myAdx = new ADX(&#39;path/to/adx/dir&#39;);
 *
 *      // List all fixtures on the ADX
 *      myAdx.getFixtureList(function (err, list) {
 *          console.log(list[0]); // -&gt; &quot;Single.xml&quot;
 *      });
 *
 * @param {Function} callback Callback
 * @param {Error} callback.err Error
 * @param {String[]} callback.list List of fixtures
 */
ADX.prototype.getFixtureList = function getFixtureList(callback) {
    var fixturePath = path.join(this.path, common.FIXTIRES_DIR_PATH);
    fs.readdir(fixturePath, function (err, files) {
        if (err) {
            callback(err, null);
            return;
        }
        var fixtures = [], i, l;
        for (i = 0, l  = files.length; i &lt; l; i += 1) {
            if (/\.xml$/.test(files[i])) {
                fixtures.push(files[i]);
            }
        }
        callback(null, fixtures);
    });
};

<span id='ADX-method-checkFixtures'>/**
</span> * Verify if the fixture exist and create it if it doesn&#39;t
 * @param {Function} callback Callback when the operation is complete
 * @param {Error} callback.err Error that occured during the operation
 */
ADX.prototype.checkFixtures = function checkFixtures(callback) {
    var self = this;

    function check(loadErr) {
        if (loadErr) {
            if (typeof callback === &#39;function&#39;) {
                callback(loadErr);
            }
            return;
        }
        var projectType = self.configurator.projectType;
        if (projectType !== &#39;adc&#39; &amp;&amp; projectType !== &#39;adp&#39;) {
            if (typeof callback === &#39;function&#39;) {
                callback(new Error(errMsg.incorrectADXType));
            }
            return;
        }

        var fixturePath = path.join(self.path, common.FIXTIRES_DIR_PATH);
        common.dirExists(fixturePath, function (err, isExist) {
            if (isExist) {
                if (typeof callback === &#39;function&#39;) {
                    callback();
                }
                return;
            }
            var testPath =  path.join(fixturePath, &#39;../&#39;);
            var sourcePath = path.join(path.resolve(__dirname, &quot;../&quot;), common.TEMPLATES_PATH, projectType, common.DEFAULT_TEMPLATE_NAME, common.FIXTIRES_DIR_PATH);

            fs.mkdir(testPath, function () {
                wrench.copyDirRecursive(sourcePath, fixturePath, {
                    forceDelete       : false,
                    excludeHiddenUnix : true,
                    preserveFiles     : true
                }, function () {
                    if (typeof callback === &#39;function&#39;) {
                        callback();
                    }
                });
            });
        });
    }

    // If the adx was not loaded, load it now
    if (!this.configurator) {
        this.load(check);
    } else {
        check(null);
    }
};

<span id='ADX-method-destroy'>/**
</span> * Release all resources
 */
ADX.prototype.destroy = function destroy() {
    this._adxShell.destroy();
    this.interviews.clear();
};

<span id='ADX-static-method-generate'>/**
</span> * Generate a new ADX structure
 *
 *      // Generate the ADC structure in &#39;/path/of/parent/dir/myNewADC&#39;
 *      ADX.generate(&#39;adc&#39;, &#39;myNewADC&#39;, {output : &#39;/path/of/parent/dir&#39;, template : &#39;blank&#39;}, function (err, adc) {
 *          console.log(adc.path);
 *      });
 *
 *      // Generate the ADP structure in &#39;/path/of/parent/dir/myMewADP&#39;
 *      ADX.generate(&#39;adp&#39;, &#39;myNewADP&#39;, {output : &#39;/path/of/parent/dir&#39;, template : &#39;blank&#39;, function (err, adp) {
 *          console.log(adp.path);
 *      });
 *
 * @param {&#39;adc&#39;|&#39;adp&#39;} type Type of the ADX (&#39;adc&#39; or &#39;adp&#39;)
 * @param {String} name Name of the ADX to generate
 * @param {Object} [options] Options
 * @param {String} [options.description=&#39;&#39;] Description of the ADX
 * @param {Object} [options.author] Author of the ADX
 * @param {String} [options.author.name=&#39;&#39;] Author name
 * @param {String} [options.author.email=&#39;&#39;] Author email
 * @param {String} [options.author.company=&#39;&#39;] Author Company
 * @param {String} [options.author.website=&#39;&#39;] Author web site
 * @param {String} [options.output=process.cwd()] Path of the output director
 * @param {String} [options.template=&quot;blank&quot;] Name of the template to use
 * @param {Function} [callback]
 * @param {Error} [callback.err] Error
 * @param {ADX} [callback.adx] Instance of the new generated ADX
 * @static
 */
ADX.generate = function generate(type, name, options, callback) {
    var generator = new Generator();
    // Swap the options
    if (typeof  options === &#39;function&#39;) {
        callback = options;
        options  = null;
    }
    callback = callback || function () {};

    generator.generate(type, name, options, function (err, outputPath) {
        if (err) {
            callback(err, null);
            return;
        }
        callback(null, new ADX(outputPath));
    });
};

<span id='ADX-static-method-getTemplateList'>/**
</span> * Returns the list of templates directory
 *
 * @param {&quot;adc&quot;|&quot;adp&quot;} type Type of the template list to obtain (`adc` or `adp`)
 * @param {Function} callback Callback
 * @param {Error} callback.err Error
 * @param {Object[]} callback.dirs List of template
 * @param {String} callback.dirs[].name Name of the template
 * @param {String} callback.dirs[].path Path of the template directory
 * @static
 */
ADX.getTemplateList = function getTemplateList(type, callback) {
    common.getTemplateList(type, callback);
};

<span id='ADX-property-preferences'>/**
</span> * Instance of the object to manage the preferences
 *
 * @type {ADX.Preferences}
 */
ADX.preferences = preferences;


// Make it public
exports.ADX = ADX;
exports.Configurator = Configurator;
exports.InteractiveADXShell = InteractiveADXShell;

</pre>
</body>
</html>
